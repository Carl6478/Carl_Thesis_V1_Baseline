{"run_id": "9c91b0509b28492495b8f1dc42e649c3", "timestamp": "2026-02-10T00:43:40.898514", "model": "codegemma:7b", "task_id": "HumanEval/0", "task_prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "use_humaneval": true, "rag_enabled": false, "pass_1": 1, "pass_k": 1.0, "k": 1, "n_attempts": 1, "c_passed": 1, "attempts": [{"attempt": 1, "output": "```python\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False\n```", "code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False", "passed": true, "metrics": {"lines_of_code": 14, "comment_count": 0, "cyclomatic_complexity": 4, "cognitive_complexity": 6.0, "cognitive_complexity_avg": 6.0, "max_complexity_node": 6.0, "needs_refactor": false, "halstead_effort": 42.793987519471216}}], "raw_output": "```python\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False\n```", "extracted_code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n\n    return False", "metrics": {"lines_of_code": 14, "comment_count": 0, "cyclomatic_complexity": 4, "cognitive_complexity": 6.0, "cognitive_complexity_avg": 6.0, "max_complexity_node": 6.0, "needs_refactor": false, "halstead_effort": 42.793987519471216}, "similarity_score": null}
{"run_id": "run_49d7814e", "timestamp": "2026-02-10T00:52:44.424354", "model": "codegemma:7b", "task_id": "HumanEval/7", "task_prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "canonical_solution": "    return [x for x in strings if substring in x]\n", "use_humaneval": true, "rag_enabled": false, "pass_1": 1, "pass_k": 1.0, "k": 5, "n_attempts": 1, "c_passed": 1, "attempts": [{"attempt": 1, "output": "```python\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [string for string in strings if substring in string]\n```", "code": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [string for string in strings if substring in string]", "passed": true, "metrics": {"lines_of_code": 3, "comment_count": 0, "cyclomatic_complexity": 3, "cognitive_complexity": 0.0, "cognitive_complexity_avg": 0.0, "halstead_effort": 2.3774437510817346}}], "raw_output": "```python\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [string for string in strings if substring in string]\n```", "extracted_code": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [string for string in strings if substring in string]", "metrics": {"lines_of_code": 3, "comment_count": 0, "cyclomatic_complexity": 3, "cognitive_complexity": 0.0, "cognitive_complexity_avg": 0.0, "halstead_effort": 2.3774437510817346}, "similarity_score": null}
{"run_id": "run_7d297443", "timestamp": "2026-02-10T01:20:06.091987", "model": "codegemma:7b", "task_id": "HumanEval/21", "task_prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "use_humaneval": true, "rag_enabled": false, "pass_1": 1, "pass_k": 1.0, "k": 5, "n_attempts": 1, "c_passed": 1, "attempts": [{"attempt": 1, "output": "```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.    \"\"\"  \n    min_val = min(numbers)  # Find the minimum value in the list.\n    max_val = max(numbers)  # Find the maximum value in the list.\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]  # Calculate the scaled values.\n    return scaled_numbers  # Return the scaled list.\n```", "code": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.    \"\"\"  \n    min_val = min(numbers)  # Find the minimum value in the list.\n    max_val = max(numbers)  # Find the maximum value in the list.\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]  # Calculate the scaled values.\n    return scaled_numbers  # Return the scaled list.", "passed": true, "metrics": {"lines_of_code": 7, "comment_count": 0, "cyclomatic_complexity": 2, "cognitive_complexity": 0.0, "halstead_effort": 30.319433158222125}}], "raw_output": "```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.    \"\"\"  \n    min_val = min(numbers)  # Find the minimum value in the list.\n    max_val = max(numbers)  # Find the maximum value in the list.\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]  # Calculate the scaled values.\n    return scaled_numbers  # Return the scaled list.\n```", "extracted_code": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.    \"\"\"  \n    min_val = min(numbers)  # Find the minimum value in the list.\n    max_val = max(numbers)  # Find the maximum value in the list.\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]  # Calculate the scaled values.\n    return scaled_numbers  # Return the scaled list.", "metrics": {"lines_of_code": 7, "comment_count": 0, "cyclomatic_complexity": 2, "cognitive_complexity": 0.0, "halstead_effort": 30.319433158222125}, "similarity_score": null}
{"run_id": "run_aebfce50", "timestamp": "2026-02-10T12:22:25.501340", "model": "codegemma:7b", "task_id": "HumanEval/21", "task_prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "use_humaneval": true, "rag_enabled": false, "pass_1": 1, "pass_k": 1.0, "k": 5, "n_attempts": 1, "c_passed": 1, "attempts": [{"attempt": 1, "output": "```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return scaled_numbers\n```", "code": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return scaled_numbers", "passed": true, "metrics": {"lines_of_code": 5, "comment_count": 0, "cyclomatic_complexity": 2, "cognitive_complexity": 0.0, "halstead_effort": 30.319433158222125}}], "raw_output": "```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return scaled_numbers\n```", "extracted_code": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return scaled_numbers", "metrics": {"lines_of_code": 5, "comment_count": 0, "cyclomatic_complexity": 2, "cognitive_complexity": 0.0, "halstead_effort": 30.319433158222125}, "similarity_score": null}
{"run_id": "run_e1f19bb0", "timestamp": "2026-02-10T12:42:23.043176", "model": "codegemma:7b", "task_id": "HumanEval/33", "task_prompt": "\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n", "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "use_humaneval": true, "rag_enabled": false, "pass_1": 1, "pass_k": 1.0, "k": 5, "n_attempts": 1, "c_passed": 1, "attempts": [{"attempt": 1, "output": "```python\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a new list with only the elements at indicies divisible by three\n    sorted_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Create a new list l' with the same elements as l, except for the elements at indicies divisible by three, which are replaced with the sorted elements\n    l_prime = [l[i] if i % 3 != 0 else sorted_elements.pop(0) for i in range(len(l))]\n\n    return l_prime\n```", "code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a new list with only the elements at indicies divisible by three\n    sorted_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Create a new list l' with the same elements as l, except for the elements at indicies divisible by three, which are replaced with the sorted elements\n    l_prime = [l[i] if i % 3 != 0 else sorted_elements.pop(0) for i in range(len(l))]\n\n    return l_prime", "passed": true, "metrics": {"lines_of_code": 12, "comment_count": 2, "cyclomatic_complexity": 5, "cognitive_complexity": 1.0, "halstead_effort": 86.39999999999999}}], "raw_output": "```python\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a new list with only the elements at indicies divisible by three\n    sorted_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Create a new list l' with the same elements as l, except for the elements at indicies divisible by three, which are replaced with the sorted elements\n    l_prime = [l[i] if i % 3 != 0 else sorted_elements.pop(0) for i in range(len(l))]\n\n    return l_prime\n```", "extracted_code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a new list with only the elements at indicies divisible by three\n    sorted_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Create a new list l' with the same elements as l, except for the elements at indicies divisible by three, which are replaced with the sorted elements\n    l_prime = [l[i] if i % 3 != 0 else sorted_elements.pop(0) for i in range(len(l))]\n\n    return l_prime", "metrics": {"lines_of_code": 12, "comment_count": 2, "cyclomatic_complexity": 5, "cognitive_complexity": 1.0, "halstead_effort": 86.39999999999999}, "similarity_score": null}
